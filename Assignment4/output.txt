Comment
storage_class_specifier <- static
declaration_specifiers_opt <- epsilon
declaration_specifiers <- storage_class_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
external_declaration <- declaration
translation_unit <- external_declaration
storage_class_specifier <- register
declaration_specifiers_opt <- epsilon
declaration_specifiers <- storage_class_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
external_declaration <- declaration
translation_unit <- translation_unit external_declaration
storage_class_specifier <- static
declaration_specifiers_opt <- epsilon
declaration_specifiers <- storage_class_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
external_declaration <- declaration
translation_unit <- translation_unit external_declaration
storage_class_specifier <- extern
declaration_specifiers_opt <- epsilon
declaration_specifiers <- storage_class_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
external_declaration <- declaration
translation_unit <- translation_unit external_declaration
identifier_opt <- identifier
constant <- INTEGER_CONSTANT
enumerator <- enumeration_constant = constant-expression
enumerator-list <- enumerator
constant <- INTEGER_CONSTANT
enumerator <- enumeration_constant = constant-expression
enumerator-list <- enumerator_list , enumerator
constant <- INTEGER_CONSTANT
enumerator <- enumeration_constant = constant-expression
enumerator-list <- enumerator_list , enumerator
constant <- INTEGER_CONSTANT
enumerator <- enumeration_constant = constant-expression
enumerator-list <- enumerator_list , enumerator
constant <- INTEGER_CONSTANT
enumerator <- enumeration_constant = constant-expression
enumerator-list <- enumerator_list , enumerator
enum_specifier <- enum identifier_opt { enumerator-list }
type_specifier <- ENUM_SPECIFIER
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
init_declarator_list_opt <- epsilon
declaration <- declaration_specifiers init_declarator_list_opt ;
external_declaration <- declaration
translation_unit <- translation_unit external_declaration
type_qualifier <- VOLATILE
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
declaration_specifiers_opt <- declaration_specifiers
declaration_specifiers <- type_qualifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
identifier_list_opt <- epsilon
direct_declarator <- direct_declarator ( identifier_list_opt )
declarator <- pointer_opt direct_declarator
declaration_list_opt <- epsilon
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
jump_statement <- RETURN expression_opt ;
statement <- jump_statement
block_item <- statement
block_item_list <- block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
function_definition <- declaration_specifiers declarator declaration_list_opt compound_statement
external_declaration <- function_definition
translation_unit <- translation_unit external_declaration
type_qualifier <- CONST
function_specifier <- INLINE
type_specifier <- VOID
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
declaration_specifiers_opt <- declaration_specifiers
declaration_specifiers <- function_specifier declaration_specifiers_opt
declaration_specifiers_opt <- declaration_specifiers
declaration_specifiers <- type_qualifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
identifier_list_opt <- epsilon
direct_declarator <- direct_declarator ( identifier_list_opt )
declarator <- pointer_opt direct_declarator
declaration_list_opt <- epsilon
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
argument_expression_list_opt <- epsilonpostfix_expression <- postfix_expression(argument_expression_list_opt)
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- multiplicative_expression * cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
function_definition <- declaration_specifiers declarator declaration_list_opt compound_statement
external_declaration <- function_definition
translation_unit <- translation_unit external_declaration
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
identifier_list_opt <- epsilon
direct_declarator <- direct_declarator ( identifier_list_opt )
declarator <- pointer_opt direct_declarator
declaration_list_opt <- epsilon
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
argument_expression_list_opt <- epsilonpostfix_expression <- postfix_expression(argument_expression_list_opt)
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
jump_statement <- RETURN expression_opt ;
statement <- jump_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
function_definition <- declaration_specifiers declarator declaration_list_opt compound_statement
external_declaration <- function_definition
translation_unit <- translation_unit external_declaration
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
identifier_list_opt <- epsilon
direct_declarator <- direct_declarator ( identifier_list_opt )
declarator <- pointer_opt direct_declarator
declaration_list_opt <- epsilon
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
init_declarator <- declarator
init_declarator_list <- init_declarator
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
type_qualifier_list_opt <- epsilon
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression_opt <- assignment_expression
direct_declarator <- direct_declarator [ type_qualifier_list_opt assignment_expression_opt ]
declarator <- pointer_opt direct_declarator
init_declarator <- declarator
init_declarator_list <- init_declarator_list , init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
init_declarator <- declarator
init_declarator_list <- init_declarator
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
init_declarator <- declarator
init_declarator_list <- init_declarator_list , init_declarator
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
init_declarator <- declarator
init_declarator_list <- init_declarator_list , init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- SIGNED
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- relational_expression < shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression ++
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
Comment
Comment
block_item_list_opt <- epsilon
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- FOR ( declaration expression_opt ; expression_opt ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item_list block_item
expression_opt <- epsilon
expression_opt <- epsilon
expression_opt <- epsilon
jump_statement <- BREAK ;
statement <- jump_statement
block_item <- statement
block_item_list <- block_item
jump_statement <- CONTINUE ;
statement <- jump_statement
block_item <- statement
block_item_list <- block_item_list block_item
Comment
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- FOR ( expression_opt ; expression_opt ; expression_opt ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression - multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- relational_expression >= shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression --
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- +=
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- relational_expression > shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression - multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- relational_expression > shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- logical_and_expression && inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression - multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression - multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
postfix_expression <- postfix_expression[expression]
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression --
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- WHILE ( expression ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- FOR ( expression_opt ; expression_opt ; expression_opt ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item_list block_item
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- FLOAT_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- FLOAT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- DOUBLE
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- FLOAT_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- UNSIGNED
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression + multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression - multiplicative_expression
shift_expression <- additive_expression
relational_expression <- relational_expression <= shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression ++
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- equality_expression == relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
jump_statement <- RETURN expression_opt ;
statement <- jump_statement
selection_statement <- IF ( expression ) statement
statement <- selection_statement
block_item <- statement
block_item_list <- block_item
jump_statement <- GOTO IDENTIFIER ;
statement <- jump_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- FOR ( expression_opt ; expression_opt ; expression_opt ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item_list block_item
Comment
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
type_qualifier_list_opt <- epsilon
pointer <- * type_qualifier_list_opt
pointer_opt <- pointer
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
unary_operator <- &
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression <- IDENTIFIER
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
unary_operator <- *
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression . IDENTIFIER
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression ++
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression --
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
unary_expression <- INCRE unary_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression ++
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression --
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
unary_expression <- DECRE unary_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
type_specifier <- INT
specific_qualifier_list_opt <- epsilon
specific_qualifier_list <- type_specifier specific_qualifier_list_opt
type_name <- specific_qualifier_list
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
cast_expression <- (type_name)cast_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- and_expression & equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- inclusive_or_expression | exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- exclusive_or_expression ^ and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
unary_operator <- !
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- multiplicative_expression * cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- multiplicative_expression / cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression + multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- =
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- multiplicative_expression % cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- +=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- -=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- *=
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- /=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- %=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- <<=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- >>=
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- &&=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- |=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- ^=
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- logical_and_expression && inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
unary_operator <- -
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- equality_expression == relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
primary_expression <- (expression)
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
unary_operator <- !
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
primary_expression <- (expression)
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- logical_and_expression && inclusive_or_expression
logical_or_expression <- logical_or_expression || logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
unary_operator <- &
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
unary_operator <- *
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
unary_operator <- +
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
unary_operator <- -
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
unary_operator <- ~
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
unary_operator <- !
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
unary_expression <- unary_operator cast_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
Comment
type_specifier <- _BOOL
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- _COMPLEX
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- multiplicative_expression * cast_expression
additive_expression <- multiplicative_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- additive_expression + multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- _IMAGINARY
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
type_specifier <- LONG
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- +=
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
assignment_operator <- -=
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
assignment_expression <- unary_expression assignment_operator assignment_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item_list block_item
type_specifier <- SHORT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
constant <- INTEGER_CONSTANT
primary_expression <- constant
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- relational_expression < shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression ++
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
initializer <- assignment_expression
init_declarator <- declarator = initializer
init_declarator_list <- init_declarator
init_declarator_list_opt <- init_declarator_list
declaration <- declaration_specifiers init_declarator_list_opt ;
block_item <- declaration
block_item_list <- block_item
Comment
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- FOR ( declaration expression_opt ; expression_opt ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
function_definition <- declaration_specifiers declarator declaration_list_opt compound_statement
external_declaration <- function_definition
translation_unit <- translation_unit external_declaration
type_qualifier <- RESTRICT
type_specifier <- VOID
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
declaration_specifiers_opt <- declaration_specifiers
declaration_specifiers <- type_qualifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
parameter_declaration <- declaration_specifiers declarator
parameter_list <- parameter_declaration
type_specifier <- INT
declaration_specifiers_opt <- epsilon
declaration_specifiers <- type_specifier declaration_specifiers_opt
pointer_opt <- epsilon
direct_declarator <- IDENTIFIER
declarator <- pointer_opt direct_declarator
parameter_declaration <- declaration_specifiers declarator
parameter_list <- parameter_list , parameter_declaration
parameter_type_list <- parameter_list
direct_declarator <- direct_declarator ( parameter_type_list )
declarator <- pointer_opt direct_declarator
declaration_list_opt <- epsilon
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
postfix_expression <- postfix-expression ++
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
expression_statement <- expression_opt;
statement <- expression_statement
block_item <- statement
block_item_list <- block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
statement <- compound_statement
iteration_statement <- WHILE ( expression ) statement
statement <- iteration_statement
block_item <- statement
block_item_list <- block_item
primary_expression <- INDENTIFIER
postfix_expression <- primary_expression
unary_expression <- postfix_expression
cast_expression <- unary_expression
multiplicative_expression <- cast_expression
additive_expression <- multiplicative_expression
shift_expression <- additive_expression
relational_expression <- shift_expression
equality_expression <- relational_expression
and_expression <- equality_expression
exclusive_or_expression <- and_expression
inclusive_or_expression <- exclusive_or_expression
logical_and_expression <- inclusive_or_expression
logical_or_expression <- logical_and_expression
conditional_expression <- logical_or_expression
assignment_expression <- conditional_expression
expression <- assignment_expression
expression_opt <- expression
jump_statement <- RETURN expression_opt ;
statement <- jump_statement
block_item <- statement
block_item_list <- block_item_list block_item
block_item_list_opt <- block_item_list
compound_statement <- { block_item_list_opt }
function_definition <- declaration_specifiers declarator declaration_list_opt compound_statement
external_declaration <- function_definition
translation_unit <- translation_unit external_declaration


SUCCESS
